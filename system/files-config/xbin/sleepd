#!/system/bin/sh

if [ -z "$1" ]
then
    while true
    do
        /system/bin/logwrapper "$0" wrapped
        rc=$?
        [ $rc != 33 ] && break
    done
    exit $rc
fi

log() {
    echo >&2 "$1"
    [ -e "/mnt/sdcard/sleepd.log" ] && echo "$1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar /system/bin/app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar /system/bin/app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar /system/bin/app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

get_uptime() {
    local uptime
    read uptime < /proc/uptime
    echo ${uptime%%.*}
}

check_governor() {
    local governor
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [ "$governor" != "$1" ]
    then
        echo "$1" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor to $1"
        return 0
    fi
    return 1
}

sleepd() {
    # ignore log up to $marker
    while read line
    do
        [ "$line" != "${line%$marker*}" ] && break
    done

    # start reacting to messages
    time=$(get_uptime)
    last_msg_ts=$time
    last_ping_ts=0
    while read line
    do
        # check if logcat - sleepd - logwrapper loop is still working
        time=$(get_uptime)
        case "$line" in
        */sleepd*)
            last_msg_ts=$time
            ;;
        *)
            if [ $((time-last_msg_ts)) -gt 60 ] && [ $((time-last_ping_ts)) -gt 5 ]
            then
                if [ $((time-last_msg_ts)) -lt 90 ]
                then
                    log "($time) ping"
                    last_ping_ts=$time
                else
                    log "($time) exiting to induce restart"
                    exit 33
                fi
            fi
        esac
        # check for messages to react to
        case "$line" in
        */sleepd*state=0*)
            state_reached=0
            continue
            ;;
        */sleepd*state=1*)
            state_reached=1
            continue
            ;;
        */sleepd*state=2*)
            state_reached=2
            continue
            ;;
        */sleepd*)
            continue  # ignore own messages
            ;;
        *showSystemImage:\ index:-1*)
            log "$line"
            if [ $state = 0 ]
            then
                am broadcast -a refresh_screen
                log "refresh_screen requested"
            fi
            ;;
        *WindowManager\(*\):\ Window\ freeze\ timeout\ expired.*)
            log "$line"
            am broadcast -a refresh_screen
            log "refresh_screen requested"
            ;;
        *{showSystemImage:\ index:0|updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state|handleInterceptActions:\ Not\ passing\ key\ to\ user|Going\ to\ sleep\ by\ user\ request...|Going\ to\ sleep\ due\ to\ screen\ timeout...}*)
            log "$line"
            if [ $state = 0 ]
            then
                check_governor performance
                powerkey
        		state=1
                log "powerkey, state=1"
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            log "$line"
            if [ $state = 1 ]
            then
                powerkey
        		state=2
                log "powerkey, state=2"
            elif [ $state = 2 ]
            then
		        state=0
                log "reset to state=0"
            fi
            mode="on"
            check_governor interactive
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            log "$line"
            if [ $state -gt 0 ]
            then
        		state=0
                log "reset to state=0"
            fi
            mode="standby"
            check_governor interactive
            # Probably of no use:
            echo "0" > /sys/class/graphics/fb0/blank
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            if [ $state = 0 ]
            then
                powerkey
		        state=1
                log "powerkey, state=1"
            elif [ $state = 1 ]
            then
        		state=0
                log "reset to state=0"
            elif [ $state = 2 ]
            then
		        state=0
                log "state=0"
            fi
            mode="mem"
            ;;
        *{Excessive\ delay|Going\ to\ sleep|showSystemImage:|handleInterceptActions:|screen|Power|power}*)
            log "$line"
            ;;
        *update_to_display*)
            check_governor performance && log "$line"
            ;;
        esac
    done
}


marker="== started sleepd $$ at $(busybox date) =="
log "$marker"

#/system/bin/busybox renice -10 $$
#echo 400000 > /sys/power/device_suspend_time_threshold
/system/bin/busybox renice 19 $(/system/bin/busybox pgrep "mmcqd/1")

#settings set system screen_off_timeout 300000
log "System's screen off timeout is set to $(($(settings get system screen_off_timeout)/1000)) s"

state=0
state_reached=0
mode="on"

/system/bin/logcat -b system -b main -b events | sleepd

# Todo: React to these by waking the device up?
#10-03 20:06:01.070 D/InputManager-JNI( 2371): handleInterceptActions: Waking up.
#10-03 20:06:01.090 I/InputDispatcher( 2371): Dropped event because input dispatch is disabled.
#10-03 20:06:01.090 D/pms     ( 2371): userActivityNoUpdateLocked: reject all events except the POWER/FORCE_WAKEUP key
# can we do s.th. against loudspeaker clicks?

# No use: Fixing brightness with
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/actual_brightness
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness
