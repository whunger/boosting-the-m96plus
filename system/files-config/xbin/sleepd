#!/system/bin/sh

if [[ -z "$1" ]]
then
    while true
    do
        logwrapper "$0" wrapped
        rc=$?
        [[ $rc != 33 ]] && break
    done
    exit $rc
fi

snore() {
    read -t $1 < /dev/ttymxc3
}

log() {
    echo >&2 "$1"
    [[ -e /mnt/sdcard/sleepd.log ]] && echo "$(date) $1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

refresh_screen() {
    am broadcast -a refresh_screen
}

get_n_blocked() {
    # get number of blocked processes
    local label
    local v0
    local rest
    while read label v0 rest
    do
        if [[ "$label" == "procs_blocked" ]]
        then
            echo $v0
            break
        fi
    done < /proc/stat
}

get_cs_time() {
    # get time in centiseconds
    local up
    local idle
    read up idle < /proc/uptime
    echo ${up/./}
}

get_sdma_irq_count() {
    # detect sound playback activity from /proc/interrupts:
    # 34:     380783       GIC  sdma
    local irq
    local n
    local remainder
    while read irq n remainder
    do
        if [[ "$irq" = "34:" ]]
        then
            echo $n
            break
        fi
    done < /proc/interrupts
}

get_mmc1_irq_count() {
    # detect mmc1 activity from /proc/interrupts:
    # 54:      55724       GIC  mmc1
    local irq
    local n
    local remainder
    while read irq n remainder
    do
        if [[ "$irq" = "54:" ]]
        then
            echo $n
            break
        fi
    done < /proc/interrupts
}
 
get_digitizer_irq_count() {
    # detect digitizer activity from /proc/interrupts:
    # 59:    2245615       GIC  IMX-uart
    local irq
    local n
    local remainder
    while read irq n remainder
    do
        if [[ "$irq" = "59:" ]]
        then
            echo $n
            break
        fi
    done < /proc/interrupts
}
 
is_on_ac() {
    local state
    read state < /sys/devices/platform/imx-i2c.1/i2c-1/1-0050/power_supply/usb/online
    if [[ "$state" = "1" ]]
    then
        return 0
    else
        return 1
    fi
}

set_screenlock() {
    if [[ "$1" == "locked" ]]
    then
        touch /mnt/shm/sleepd_screenlock
        dumpsys battery set ac 1
        dumpsys battery set status 2
        log "locked screen to on state by simulating ac power"
        # does this work also?
        snore 1
        dumpsys battery reset
    elif [[ "$1" == "unlocked" ]]
    then
        dumpsys battery reset
        rm -f /mnt/shm/sleepd_screenlock
        log "released screenlock"
    fi
}

screenlock_timeout() {
    local screen_on_time
    local time
    local remaining
    local timeout_seconds
    remaining=1
    timeout_seconds=15
    while [[ $remaining -gt 0 ]]
    do
        snore $remaining
        if [[ -e /mnt/shm/sleepd_screenlock ]]
        then
            screen_on_time=$(busybox date +%s -r /mnt/shm/sleepd_screenlock)
            time=${EPOCHREALTIME%%.*}
            remaining=$((screen_on_time+timeout_seconds-time))
        else
            remaining=0
        fi
    done
    set_screenlock unlocked
}

keep_screen_responsive() {
    local time
    local t0
    local n_irq_before
    local n_irq
    # make sure screen stays on while user interacts
    log "Started child process for screen wakelock"
    n_irq_before="0$(get_digitizer_irq_count)"
    while true
    do
        n_irq="0$(get_digitizer_irq_count)"
        if [[ $n_irq -gt $n_irq_before ]]
        then
            n_irq_before=$n_irq
            if [[ "$(getprop sys.onyx.pwrmode)" == "mem" ]]
            then
                snore 10
            elif [[ -e /mnt/shm/sleepd_screenlock ]]
            then
                # just renew timestamp
                touch /mnt/shm/sleepd_screenlock
                snore 3
            else
                # lock and start timeout process
                set_screenlock locked
                screenlock_timeout &
                snore 3
            fi
        else
            snore 0.1
        fi
        #get_digitizer_irq_count
        #busybox head -c 1 < /dev/input/event1 > /dev/null
        #t0=${EPOCHREALTIME%%.*}
        #snore 0.1
        #busybox timeout -t 2 busybox head -c 1 < /dev/input/event1 > /dev/null
        #time=${EPOCHREALTIME%%.*}
        #if [[ $((time-t0)) -gt 1 ]]
        #then
        #    log "spurious input"
        #elif [[ "$(getprop sys.onyx.pwrmode)" == "mem" ]]
        #then
        #    snore 10
        #elif [[ -e /mnt/shm/sleepd_screenlock ]]
        #then
        #    # just renew timestamp
        #    touch /mnt/shm/sleepd_screenlock
        #    snore 3
        #else
        #    # lock and start timeout process
        #    set_screenlock locked
        #    screenlock_timeout &
        #    snore 3
        #fi
    done
}

io_watchdog() {
    local time
    local check_sdma_time
    local check_mmc_time
    local check_blocked_time
    local n_sdma_before
    local n_sdma
    local n_mmc1_before
    local n_mmc1
    local sound_active
    local mmc1_active
    local io_blocked
    log "Started child process for I/O dependent workarounds"
    n_sdma_before="0$(get_sdma_irq_count)"
    n_mmc1_before="0$(get_mmc1_irq_count)"
    time=${EPOCHREALTIME%%.*}
    check_sdma_time=$((time+1))
    check_mmc_time=$((time+2))
    check_blocked_time=$((time+3))
    sound_active=1
    mmc1_active=1
    while true
    do
        time=${EPOCHREALTIME%%.*}
        if [[ $time -ge $check_sdma_time ]]
        then
            # make sure speakers are muted when not in use
            n_sdma="0$(get_sdma_irq_count)"
            if [[ $n_sdma -gt $n_sdma_before ]]
            then
                # DMA activity = sound playing
                n_sdma_before=$n_sdma
                sound_active=1
            else
                tinymix "ClassD Speaker Control" Off
                sound_active=0
            fi
            check_sdma_time=$((time+1))
        fi
        if [[ $time -ge $check_mmc_time ]]
        then
            n_mmc1="0$(get_mmc1_irq_count)"
            if [[ $n_mmc1 -gt $n_mmc1_before ]]
            then
                n_mmc1_before=$n_mmc1
                mmc1_active=1
                check_mmc_time=$((time+3))
            else
                mmc1_active=0
                check_mmc_time=$((time+30))
            fi
        fi
        if [[ $time -ge $check_blocked_time ]]
        then
            if [[ "0$(get_n_blocked)" -gt 3 ]]
            then
                io_blocked=1
                check_blocked_time=$((time+3))
            else
                io_blocked=0
                check_blocked_time=$((time+30))
            fi
        fi
        if [[ $((io_blocked + mmc_active)) -gt 0 ]]
        then
            set_io_wakelock locked
            check_governor auto
        else
            set_io_wakelock unlocked
        fi
        snore 1
    done
}

set_io_wakelock() {
    # make sure device stays awake while processes wait for i/o
    if [[ "$1" == "locked" ]]
    then
        echo sleepd_io > /sys/power/wake_lock
        if [[ 0$wakelock -eq 0 ]]
        then
            wakelock=1
            log "Acquired wakelock"
        fi
    else
        echo sleepd_io > /sys/power/wake_unlock
        if [[ 0$wakelock -eq 1 ]]
        then
            wakelock=0
            log "Released wakelock"
        fi
    fi
    # cat /proc/wakelocks
    # name    count   expire_count    wake_count      active_since
}

check_governor() {
    local governor
    local target
    if [[ "$1" == "auto" ]]
    then
        if [[ "0$(get_n_blocked)" -gt 0 ]]
        then target="performance"
        else target="interactive"
        fi
    else
        target="$1"
    fi
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [[ "$governor" != "$target" ]]
    then
        echo "$target" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor from $governor to $target"
        return 0
    fi
    return 1
}

init_mixer() {
    # sensible defaults, but does not help against loudspeaker pops
    tinymix "Capture Volume" 0
    tinymix "Right Output Mixer Boost Bypass Switch" 1
    tinymix "Left Output Mixer Boost Bypass Switch" 1
    tinymix "Speaker Playback ZC Switch" 1 1
}

init_screen() {
    settings put global window_animation_scale 0.0
    settings put global animator_duration_scale 0.0
    settings put global transition_animation_scale 0.0
    setprop persist.sys.ui.hw true
    #busybox renice -10 $(busybox pgrep /system/bin/surfaceflinger)
    busybox renice -19 $(busybox pgrep /system/bin/onyx_tpd)
    setprop sys.interactive active
    echo interactive > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    echo 396000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    echo 996000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    echo 5000 > /sys/devices/system/cpu/cpufreq/interactive/timer_rate
    echo 1 > /sys/devices/system/cpu/cpufreq/interactive/input_boost
    echo 60000000 > /sys/devices/system/cpu/cpufreq/interactive/min_sample_time
    echo 80 > /sys/devices/system/cpu/cpufreq/interactive/go_hispeed_load
    #echo 1 > /sys/devices/system/cpu/cpufreq/interactive/io_is_busy
    echo 996000 > /sys/devices/system/cpu/cpufreq/interactive/hispeed_freq
}

init_vm() {
    # Aggressive:
    # Foreground Applications: 6400
    # Visible Applications: 7680
    # Secondary Server: 11520
    # Hidden Applications: 25600
    # Content Providers: 35840
    # Empty Applications: 38400
    #echo "6400,7680,11520,25600,35840,38400" > /sys/module/lowmemorykiller/parameters/minfree
    # Default LMK:
    #echo "12288,15360,18432,21504,24576,30720" > /sys/module/lowmemorykiller/parameters/minfree
    # start writing at 20 MB, don't buffer more than 100 MB:
    #echo 2 > /proc/sys/vm/dirty_background_ratio
    #echo 10 > /proc/sys/vm/dirty_ratio
    # instead of echo 1 > /proc/sys/vm/drop_caches
    #echo 1000 > /proc/sys/vm/vfs_cache_pressure
    # Default is 2884:
    #echo 32768 > /proc/sys/vm/min_free_kbytes
    # Default is 60:
    #echo 0 > /proc/sys/vm/swappiness
    # Faster I/O? From https://sites.google.com/site/tweakradje/android/android-tweaking
    # Seems to improve I/O performance (and might trigger OOM killer).
    #echo 1 > /proc/sys/vm/highmem_is_dirtyable
    # Default is cfq:
    echo "deadline" > /sys/block/mmcblk0/queue/scheduler
    echo 1 > /sys/block/mmcblk0/queue/iosched/fifo_batch
    echo 10 > /sys/block/mmcblk0/queue/iosched/read_expire
    echo 150  > /sys/block/mmcblk0/queue/iosched/write_expire
    # read ahead buffer size
    echo 1024 > /sys/block/mmcblk0/queue/read_ahead_kb
    if mount | grep -q /mnt/extsd
    then
        log "setting mmcblk1 queue parameters"
        echo "deadline" > /sys/block/mmcblk1/queue/scheduler
        echo 1 > /sys/block/mmcblk1/queue/iosched/fifo_batch
        echo 10 > /sys/block/mmcblk1/queue/iosched/read_expire
        echo 50  > /sys/block/mmcblk1/queue/iosched/write_expire
        echo 1024 > /sys/block/mmcblk1/queue/read_ahead_kb
    fi
    # Memory or CPU?
    #echo 1 > /sys/kernel/mm/ksm/run
    #echo 1000 > /sys/kernel/mm/ksm/sleep_millisecs
    #echo 128 > /sys/kernel/mm/ksm/pages_to_scan
}

change_mode() {
    local mode
    mode=$1
    case "$2" in
    *SYSTEM\ POWER\ STATE:\ \[mem\]*)
        mode="mem"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[on\]*)
        mode="on"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[standby\]*)
        mode="standby"
        ;;
    esac
    echo $mode
}

is_blocked() {
    if [[ $time -le $block_time ]]
    then
        log "$((block_time-time)) s of blocking interval left"
        return 0
    else
        return 1
    fi
}

do_restart_power_service() {
    log "restart_power_service"
    stop power
    start power
    log "restart_power_service: exiting to induce restart"
    kill $keep_screen_responsive_pid
    kill $io_watchdog_pid
    exit 33
}

do_enter_suspend() {
    set_screenlock unlocked
    set_io_wakelock unlocked
    if [[ "$mode" == "standby" ]]
    then
        ( powerkey ; snore 1 ; powerkey ) &
        block_time=$((time+60))
        log "enter_suspend ($mode): powerkey-sleep-powerkey, releasing locks, blocking for 60 s"
    else
        log "enter suspend ($mode): releasing locks"
    fi
}

do_sleep() {
    log "sleep: sleeping now ..."
    set_screenlock unlocked
}

do_wakeup() {
    log "wakeup: init_mixer, blocking for 15 s"
    init_mixer
    set_screenlock unlocked
    check_governor performance
    refresh_screen
    block_time=$((time+15))
}

do_activity() {
    check_governor auto
}

do_throttle() {
    #log "throttle: governor=auto"
    #check_governor auto
    #log "throttle: governor=performance regardless"
    #check_governor performance
}

do_refresh_screen() {
    refresh_screen
    log "refresh_screen, blocking for 2 s"
    block_time=$((time+2))
}

do_screenshot() {
    screencap -p /mnt/sdcard/Pictures/Screenshots/"$(date +"%Y-%m-%d_%H_%M_%S").png"
}

sleepd() {
    # ignore log up to $marker
    mode="on"
    while read line
    do
        mode=$(change_mode "$mode" "$line")
        [[ "$line" != "${line%$marker*}" ]] && break
    done

    refresh_screen
    log "Screen refresh to indicate sleepd start"

    # start reacting to messages
    time=${EPOCHREALTIME%%.*}
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    block_time=$((time+1))
    while read line
    do
        time=${EPOCHREALTIME%%.*}

        [[ "$mode" = "mem" ]] && tinymix "ClassD Speaker Control" Off

        # check for messages to react to
        case "$line" in
        */sleepd*)
            # Still in sync
            ping_time=$((time+60))
            ping_count=3
            continue  # loop, do not interpret own log messages
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            # First indicator of Onyx software starting to suspend the device
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *Go\ to\ Sleep\ as\ POWER\ key\ is\ pressed*)
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            do_sleep
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            #log "$line"
            if [[ "$mode" = "mem" ]] && ! is_blocked
            then do_wakeup
            elif [[ "$mode" = "standby" ]] && ! is_blocked
            then do_activity
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            #log "$line"
            if [[ "$mode" = "mem" ]] && ! is_blocked
            then do_wakeup
            elif [[ "$mode" = "on" ]] && ! is_blocked
            then do_throttle
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[\]*)
            log "$line"
            #do_restart_power_service
            ;;
        *SYSTEM\ POWER\ STATE:*)
            log "$line"
            log "Unknown power state!"
            ;;
        *volume\ state\ changed\ for\ /storage/*\ mounted*)
            log "$line"
            init_vm
            ;;
        #*android.util.PhoneWindowHelper.onLongPress*)
        *android.hardware.DeviceController.sendOpenAndCloseFrontLightBroadcast*)
            do_screenshot
            ;;
        #*update_to_display*)
        #*handleInterceptActions:\ Waking\ up.*)
        esac

        mode=$(change_mode "$mode" "$line")

        # check if logcat - sleepd - logwrapper loop is still working
        if [[ $time -ge $ping_time ]] && [[ $ping_count -gt 0 ]]
        then
            echo >&2 "ping"
            ping_count=$((ping_count-1))
            ping_time=$((time+15))
            if [[ $ping_count = 0 ]]
            then
                exit_time=$((time+1))
            fi
        elif [[ $time -ge $exit_time ]]
        then
            log "unable to receive pings, exiting to induce restart"
            kill $keep_screen_responsive_pid
            kill $io_watchdog_pid
            exit 33
        fi
    done
}


marker="== started sleepd $$ at $(date) =="
log "$marker"

init_mixer
log "Set mixer defaults"

init_vm
log "Set defaults for vm management"

#settings put system screen_off_timeout 30000
#settings put system screen_off_timeout 300000
log "System's screen off timeout is set to $((0$(settings get system screen_off_timeout)/1000)) s"

# From Kernel 3.4 on ... setprop sys.sysctl.extra_free_kbytes 16384

init_screen
log "Set defaults for screen performance"

set_screenlock unlocked

keep_screen_responsive &
keep_screen_responsive_pid=$!

io_watchdog &
io_watchdog_pid=$!

log "Waiting for system to settle ..."
while [[ "0$(get_n_blocked)" -gt 0 ]]
do
    snore 5
done

logcat -b system -b main -b events | sleepd

# * sys.onyx.pwrmode can be one of on/standby/mem
# * to test with adb running use "dumpsys battery set ac 0"
