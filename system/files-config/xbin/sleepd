#!/system/bin/sh

if [[ -z "$1" ]]
then
    while true
    do
        logwrapper "$0" wrapped
        rc=$?
        [[ $rc != 33 ]] && break
    done
    exit $rc
fi

log() {
    echo >&2 "$1"
    [[ -e /mnt/sdcard/sleepd.log ]] && echo "$(date) $1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

refresh_screen() {
    am broadcast -a refresh_screen
}

get_n_blocked() {
    # get number of blocked processes
    local label
    local v0
    local rest
    while read label v0 rest
    do
        if [[ "$label" == "procs_blocked" ]]
        then
            echo $v0
            break
        fi
    done < /proc/stat
}

get_cs_time() {
    # get time in centiseconds
    local up
    local idle
    read up idle < /proc/uptime
    echo ${up/./}
}

# * detect user inactivity from /proc/interrupts
# * detect power button presses from /proc/interrupts
# * the Hanvon pen is connected to the 2nd uart (IRQ 59)
# * buttons are connected to GPIO pins
#
#  59:     115712       GIC  IMX-uart
#  87:      63859       GIC  i.MX Timer Tick
# 338:          0      GPIO  btn power
# 344:         10      GPIO  btn 4K_pgdn
# 345:         14      GPIO  btn 5K_left
# 346:          8      GPIO  btn 4K_pgup
# 347:         26      GPIO  btn 5K_right
# 348:          6      GPIO  btn 4K_menu
# 349:          4      GPIO  btn 5K_ok
# 350:         10      GPIO  btn 4K_back
# 351:         36      GPIO  btn 5K_up
# 352:          2      GPIO  btn VOL_UP
# 353:         80      GPIO  btn 5K_down
# 354:          4      GPIO  btn VOL_DOWN

get_pen_irq_count() {
    local irq
    local n
    local type
    local name
    while read irq n type name
    do
        if [[ "$irq" = "59:" ]]
        then
            echo $n
            break
        fi
    done < /proc/interrupts
}

is_on_ac() {
    if dumpsys battery | grep "AC powered: true"
    then return 1
    else return 0
    fi
}

set_screenlock() {
    if [[ "$1" == "locked" ]]
    then
        touch /mnt/shm/sleepd_screenlock
        dumpsys battery set ac 1
        dumpsys battery set status 0
        log "locked screen to on state by simulating ac power"
    elif [[ "$1" == "unlocked" ]]
    then
        dumpsys battery reset
        rm -f /mnt/shm/sleepd_screenlock
        log "released screenlock"
    fi
}

screenlock_timeout() {
    local screen_on_time
    local time
    local remaining
    remaining=1
    while [[ $remaining -gt 0 ]]
    do
        sleep $remaining
        if [[ -e /mnt/shm/sleepd_screenlock ]]
        then
            screen_on_time=$(busybox date +%s -r /mnt/shm/sleepd_screenlock)
            time=${EPOCHREALTIME%%.*}
            remaining=$((screen_on_time+60-time))
        else
            remaining=0
        fi
    done
    set_screenlock unlocked
}

keep_screen_responsive() {
    # make sure screen stays on while user interacts
    log "Started child process for screen wakelock"
    while true
    do
        busybox head -c 1 < /dev/input/event1 > /dev/null
        if [[ "$(getprop sys.onyx.pwrmode)" == "mem" ]]
        then
            sleep 300
        elif [[ -e /mnt/shm/sleepd_screenlock ]]
        then
            # just renew timestamp
            touch /mnt/shm/sleepd_screenlock
            sleep 3
        else
            # lock and start timeout process
            sleep 0.5
            set_screenlock locked
            screenlock_timeout &
        fi
    done
}

set_wakelock() {
    # make sure device stays awake while processes wait for i/o
    if [[ "$1" == "locked" ]]
    then echo sleepd_io > /sys/power/wake_lock
    else echo sleepd_io > /sys/power/wake_unlock
    fi
}

check_governor() {
    local governor
    local target
    if [[ "$1" == "auto" ]]
    then
        if [[ "0$(get_n_blocked)" -gt 0 ]]
        then target="performance"
        else target="ondemand"
        fi
    else
        target="$1"
    fi
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [[ "$governor" != "$target" ]]
    then
        echo "$target" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor from $governor to $target"
        return 0
    fi
    return 1
}

check_io() {
    # make sure device stays awake while processes wait for i/o
    if [[ "0$(get_n_blocked)" -gt 0 ]]
    then
        set_wakelock locked
        check_governor performance
    else
        set_wakelock unlocked
    fi
}

check_discard() {
    if [[ -d "$1" ]] && mount | grep -q "$1"
    then
        log "mount -o remount,discard,noatime,norelatime,nosuid,nodev,noexec $1"
        mount -o remount,discard,noatime,norelatime,nosuid,nodev,noexec "$1"
    fi
}

init_mixer() {
    # sensible defaults, but does not help against loudspeaker pops
    tinymix "Capture Volume" 0
    tinymix "Right Output Mixer Boost Bypass Switch" 1
    tinymix "Left Output Mixer Boost Bypass Switch" 1
    tinymix "Speaker Playback ZC Switch" 1 1
}

init_screen() {
    settings put global window_animation_scale 0.0
    settings put global animator_duration_scale 0.0
    settings put global transition_animation_scale 0.0
    setprop persist.sys.ui.hw true
    busybox renice -10 $(busybox pgrep /system/bin/surfaceflinger)
}

init_vm() {
    # start writing at 20 MB, don't buffer more than 50 MB:
    echo 2 > /proc/sys/vm/dirty_background_ratio
    echo 5 > /proc/sys/vm/dirty_ratio
    # Use fs cache!
    echo 50 > /proc/sys/vm/vfs_cache_pressure
    # Default is 60:
    echo 10 > /proc/sys/vm/swappiness
    # Limit number of background processes
    #service call activity 51 i32 3
    # Limit this process and its children
    #ulimit -Sv 16384
}

init_swap() {
    [ -e /cache/swap ] && grep -q /cache/swap /proc/swaps || swapon /cache/swap
}

change_mode() {
    local mode
    mode=$1
    case "$2" in
    *SYSTEM\ POWER\ STATE:\ \[mem\]*)
        mode="mem"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[on\]*)
        mode="on"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[standby\]*)
        mode="standby"
        ;;
    esac
    echo $mode
}

is_blocked() {
    if [[ $time -le $block_time ]]
    then
        log "$((block_time-time)) s of blocking interval left"
        return 0
    else
        return 1
    fi
}

do_restart_power_service() {
    log "restart_power_service"
    stop power
    start power
    log "restart_power_service: exiting to induce restart"
    kill $keep_screen_responsive_pid
    exit 33
}

do_enter_suspend() {
    set_screenlock unlocked
    set_wakelock unlocked
    if [[ "$mode" == "standby" ]]
    then
        ( powerkey ; sleep 1 ; powerkey ) &
        block_time=$((time+60))
        log "enter_suspend ($mode): keep_screen_on-powerkey-sleep-powerkey, releasing wakelock, blocking for 60 s"
    else
        log "enter suspend ($mode): releasing wakelock"
    fi
}

do_sleep() {
    log "sleep: sleeping now ..."
    set_screenlock unlocked
}

do_wakeup() {
    log "wakeup: init_mixer, blocking for 15 s"
    init_mixer
    set_screenlock unlocked
    #check_governor performance
    refresh_screen
    block_time=$((time+15))
}

do_activity() {
    #touch /mnt/shm/sleepd_screenlock
    #check_governor auto
    #log "activity: governor=performance"
}

do_throttle() {
    #log "throttle: governor=auto"
    #check_governor auto
    #log "throttle: governor=performance regardless"
    #check_governor performance
}

do_refresh_screen() {
    refresh_screen
    log "refresh_screen, blocking for 2 s"
    block_time=$((time+2))
}

do_screenshot() {
    screencap -p /mnt/sdcard/Pictures/Screenshots/"$(date +"%Y-%m-%d_%H_%M_%S").png"
}

sleepd() {
    # ignore log up to $marker
    mode="on"
    while read line
    do
        mode=$(change_mode "$mode" "$line")
        [[ "$line" != "${line%$marker*}" ]] && break
    done

    refresh_screen
    log "Screen refresh to indicate sleepd start"

    # start reacting to messages
    time=${EPOCHREALTIME%%.*}
    cs_time=$(get_cs_time)
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    block_time=$((time+1))
    budget=128
    while read line
    do
        time=${EPOCHREALTIME%%.*}
        last_cs_time=$cs_time
        cs_time=$(get_cs_time)
        budget=$((budget+cs_time-last_cs_time))  # + 7/s

        if [[ $budget -gt 20 ]]
        then
            [[ "$mode" != "on" ]] && tinymix "ClassD Speaker Control" Off
            [[ "$mode" != "mem" ]] && check_io
            budget=$((budget/2))
            #log "$budget"
        fi

        # check for messages to react to
        case "$line" in
        */sleepd*)
            # Still in sync
            ping_time=$((time+60))
            ping_count=3
            continue  # loop, do not interpret own log messages
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            # First indicator of Onyx software starting to suspend the device
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *Go\ to\ Sleep\ as\ POWER\ key\ is\ pressed*)
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            do_sleep
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            #log "$line"
            if [[ "$mode" = "mem" ]] && ! is_blocked
            then do_wakeup
            elif [[ "$mode" = "standby" ]] && ! is_blocked
            then do_activity
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            #log "$line"
            if [[ "$mode" = "mem" ]] && ! is_blocked
            then do_wakeup
            elif [[ "$mode" = "on" ]] && ! is_blocked
            then do_throttle
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[\]*)
            log "$line"
            #do_restart_power_service
            ;;
        *SYSTEM\ POWER\ STATE:*)
            log "$line"
            log "Unknown power state!"
            ;;
        *volume\ state\ changed\ for\ /storage/sdcard*mounted*)
            log "$line"
            check_discard /storage/sdcard
            ;;
        *volume\ state\ changed\ for\ /storage/extsd*mounted*)
            log "$line"
            check_discard /mnt/extsd
            ;;
        #*android.util.PhoneWindowHelper.onLongPress*)
        *android.hardware.DeviceController.sendOpenAndCloseFrontLightBroadcast*)
            do_screenshot
            ;;
        #*update_to_display*)
        #*handleInterceptActions:\ Waking\ up.*)
        esac

        mode=$(change_mode "$mode" "$line")

        # check if logcat - sleepd - logwrapper loop is still working
        if [[ $time -ge $ping_time ]] && [[ $ping_count -gt 0 ]]
        then
            echo >&2 "ping"
            ping_count=$((ping_count-1))
            ping_time=$((time+15))
            if [[ $ping_count = 0 ]]
            then
                exit_time=$((time+1))
            fi
        elif [[ $time -ge $exit_time ]]
        then
            log "unable to receive pings, exiting to induce restart"
            kill $keep_screen_responsive_pid
            exit 33
        fi
    done
}


marker="== started sleepd $$ at $(date) =="
log "$marker"

#echo 1000000 > /sys/power/device_suspend_time_threshold
#log "Increased device_suspend_time_threshold=$(cat /sys/power/device_suspend_time_threshold)"

init_mixer
log "Set mixer defaults"

init_vm
log "Set defaults for vm management"

#settings put system screen_off_timeout 30000
#settings put system screen_off_timeout 300000
log "System's screen off timeout is set to $((0$(settings get system screen_off_timeout)/1000)) s"

# settings/system/screen_off_timeout: pid=2731 uid=1000 user=-1 target=4175ab68
# settings/system/screen_brightness: pid=2731 uid=1000 user=-1 target=417a71c8
# settings/system/screen_brightness_mode: pid=2731 uid=1000 user=-1 target=417a71c8
# mPendingRequestLocked=screenState=0, useProximitySensor=false, screenBrightness=48, screenAutoBrightnessAdjustment=0.0, useAutoBrightness=false, blockScreenOn=false
# mPowerRequest=screenState=0, useProximitySensor=false, screenBrightness=48, screenAutoBrightnessAdjustment=0.0, useAutoBrightness=false, blockScreenOn=false
# mScreenOn=false

# Screen off timeout: 1800000 ms
# Screen dim duration: 7000 ms
# 
# Wake Locks: size=0
# 
# Suspend Blockers: size=4
#   PowerManagerService.WakeLocks: ref count=0
#   PowerManagerService.Display: ref count=0
#   PowerManagerService.Broadcasts: ref count=0
#   PowerManagerService.WirelessChargerDetector: ref count=0
# 
# Screen On Blocker: held=false, mNestCount=0
# 
# Display Blanker: blanked=true

#check_discard /storage/sdcard
#check_discard /mnt/extsd

#init_swap

# Testing:
#stop power
#busybox chrt -p -f 90 $(busybox pgrep "EPDC AA")
#busybox chrt -p -f 91 $(busybox pgrep "EPDC Submit")
#busybox chrt -p -f 92 $(busybox pgrep "EPDC Interrupt")
#busybox chrt -p -f 95 $(busybox pgrep /system/bin/surfaceflinger)
#busybox chrt -p -f 90 $(busybox pgrep /system/bin/onyx_tpd)

# From Kernel 3.4 on ... setprop sys.sysctl.extra_free_kbytes 16384

#am broadcast -a android.intent.action.BOOT_COMPLETED -c android.intent.category.HOME -n ui.robot.rotatedonate/.MyEventReceiver
#am broadcast -a android.intent.action.BOOT_COMPLETED -n ui.robot.rotatedonate/.MyEventReceiver
#am broadcast -a android.intent.action.BOOT_COMPLETED
#am broadcast -a android.intent.action.BOOT_COMPLETED -n org.crape.rotationcontrol/org.crape.rotationcontrol.BroadcastBootCompletedReceiver
#am start org.crape.rotationcontrol/.RotationControlActivity
#am broadcast -a android.intent.action.CONFIGURATION_CHANGED -n org.crape.rotationcontrol/org.crape.rotationcontrol.RotationControlService

init_screen
log "Set defaults for screen performance"

log "Waiting for system to settle ..."
while [[ "0$(get_n_blocked)" -gt 0 ]]
do
    sleep 5
done

set_screenlock unlocked

keep_screen_responsive &
keep_screen_responsive_pid=$!

logcat -b system -b main -b events | sleepd

# * sys.onyx.pwrmode can be one of on/standby/mem
# * to test with adb running use "dumpsys battery set ac 0"
#
# [hw.backlight.dev]: [pwm-backlight.0]
# [sys.onyx.pwrmode]: [standby]
# android.intent.action.USER_PRESENT
