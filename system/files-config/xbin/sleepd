#!/system/bin/sh

if [[ -z "$1" ]]
then
    while true
    do
        logwrapper "$0" wrapped
        rc=$?
        [[ $rc != 33 ]] && break
    done
    exit $rc
fi

log() {
    echo >&2 "$1"
    [[ -e /mnt/sdcard/sleepd.log ]] && echo "$(date) $1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

refresh_screen() {
    am broadcast -a refresh_screen
}

get_n_blocked() {
    # get number of blocked processes
    local label
    local v0
    local rest
    while read label v0 rest
    do
        if [[ "$label" == "procs_blocked" ]]
        then
            echo $v0
            break
        fi
    done < /proc/stat
}

get_cs_time() {
    # get time in centiseconds
    local up
    local idle
    read up idle < /proc/uptime
    echo ${up/./}
}

get_sdma_irq_count() {
    # detect sound playback activity from /proc/interrupts:
    # 34:     380783       GIC  sdma
    local irq
    local n
    local remainder
    while read irq n remainder
    do
        if [[ "$irq" = "34:" ]]
        then
            echo $n
            break
        fi
    done < /proc/interrupts
}

get_mmc1_irq_count() {
    # detect mmc1 activity from /proc/interrupts:
    # 54:      55724       GIC  mmc1
    local irq
    local n
    local remainder
    while read irq n remainder
    do
        if [[ "$irq" = "54:" ]]
        then
            echo $n
            break
        fi
    done < /proc/interrupts
}
 
is_on_ac() {
    if dumpsys battery | grep "AC powered: true"
    then return 0
    else return 1
    fi
}

set_screenlock() {
    if [[ "$1" == "locked" ]]
    then
        touch /mnt/shm/sleepd_screenlock
        dumpsys battery set ac 1
        log "locked screen to on state by simulating ac power"
    elif [[ "$1" == "unlocked" ]]
    then
        dumpsys battery reset
        rm -f /mnt/shm/sleepd_screenlock
        dumpsys battery reset
        log "released screenlock"
    fi
}

screenlock_timeout() {
    local screen_on_time
    local time
    local remaining
    remaining=1
    while [[ $remaining -gt 0 ]]
    do
        sleep $remaining
        if [[ -e /mnt/shm/sleepd_screenlock ]]
        then
            screen_on_time=$(busybox date +%s -r /mnt/shm/sleepd_screenlock)
            time=${EPOCHREALTIME%%.*}
            remaining=$((screen_on_time+60-time))
        else
            remaining=0
        fi
    done
    set_screenlock unlocked
}

keep_screen_responsive() {
    local time
    local t0
    # make sure screen stays on while user interacts
    log "Started child process for screen wakelock"
    while true
    do
        busybox head -c 1 < /dev/input/event1 > /dev/null
        t0=${EPOCHREALTIME%%.*}
        sleep 0.1
        busybox timeout -t 2 busybox head -c 1 < /dev/input/event1 > /dev/null
        time=${EPOCHREALTIME%%.*}
        if [[ $((time-t0)) -gt 1 ]]
        then
            log "spurious input"
        elif [[ "$(getprop sys.onyx.pwrmode)" == "mem" ]]
        then
            sleep 300
        elif [[ -e /mnt/shm/sleepd_screenlock ]]
        then
            # just renew timestamp
            touch /mnt/shm/sleepd_screenlock
            sleep 30
        else
            # lock and start timeout process
            sleep 0.3
            set_screenlock locked
            screenlock_timeout &
            sleep 30
        fi
    done
}

io_watchdog() {
    local time
    local check_sdma_time
    #local check_mmc_time
    local check_io_time
    local n_sdma_before
    local n_sdma
    #local n_mmc1_before
    #local n_mmc1
    local sound_active
    #local mmc1_active
    log "Started child process for I/O dependent workarounds"
    n_sdma_before="0$(get_sdma_irq_count)"
    #n_mmc1_before="0$(get_mmc1_irq_count)"
    time=${EPOCHREALTIME%%.*}
    check_sdma_time=$((time+1))
    #check_mmc_time=$((time+300))
    check_io_time=$((time+30))
    sound_active=1
    #mmc1_active=1
    while true
    do
        time=${EPOCHREALTIME%%.*}
        if [[ $time -ge $check_sdma_time ]]
        then
            # make sure speakers are muted when not in use
            n_sdma="0$(get_sdma_irq_count)"
            if [[ $n_sdma -gt $n_sdma_before ]]
            then
                # DMA activity = sound playing
                n_sdma_before=$n_sdma
                sound_active=1
            else
                tinymix "ClassD Speaker Control" Off
                sound_active=0
            fi
            check_sdma_time=$((time+1))
        fi
        #if [[ $time -ge $check_mmc_time ]]
        #then
        #    n_mmc1="0$(get_mmc1_irq_count)"
        #    if [[ $n_mmc1 -gt $n_mmc1_before ]]
        #    then
        #        n_mmc1_before=$n_mmc1
        #        mmc1_active=1
        #    else
        #        mmc1_active=0
        #    fi
        #    check_mmc_time=$((time+300))
        #fi
        if [[ $time -ge $check_io_time ]]
        then
            check_io
            check_io_time=$((time+30))
        fi
        sleep 1
    done
}

set_wakelock() {
    # make sure device stays awake while processes wait for i/o
    if [[ "$1" == "locked" ]]
    then
        echo sleepd_io > /sys/power/wake_lock
        if [[ 0$wakelock -eq 0 ]]
        then
            wakelock=1
            log "Acquired wakelock"
        fi
    else
        echo sleepd_io > /sys/power/wake_unlock
        if [[ 0$wakelock -eq 1 ]]
        then
            wakelock=0
            log "Released wakelock"
        fi
    fi
    # cat /proc/wakelocks
    # name    count   expire_count    wake_count      active_since
}

check_governor() {
    local governor
    local target
    if [[ "$1" == "auto" ]]
    then
        if [[ "0$(get_n_blocked)" -gt 0 ]]
        then target="performance"
        else target="ondemand"
        fi
    else
        target="$1"
    fi
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [[ "$governor" != "$target" ]]
    then
        echo "$target" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor from $governor to $target"
        return 0
    fi
    return 1
}

check_io() {
    # make sure device stays awake while processes wait for i/o
    if [[ "0$(get_n_blocked)" -gt 3 ]]
    then
        set_wakelock locked
        check_governor performance
        sync
        #echo 1 > /proc/sys/vm/drop_caches
        #dd if=/dev/zero of=/mnt/shm/x bs=1024 count=20000
        #rm /mnt/shm/x
    else
        set_wakelock unlocked
    fi
}

check_discard() {
    if [[ -d "$1" ]] && mount | grep -q "$1"
    then
        log "mount -o remount,discard,noatime,norelatime,nosuid,nodev,noexec $1"
        mount -o remount,discard,noatime,norelatime,nosuid,nodev,noexec "$1"
    fi
}

init_mixer() {
    # sensible defaults, but does not help against loudspeaker pops
    tinymix "Capture Volume" 0
    tinymix "Right Output Mixer Boost Bypass Switch" 1
    tinymix "Left Output Mixer Boost Bypass Switch" 1
    tinymix "Speaker Playback ZC Switch" 1 1
}

init_screen() {
    settings put global window_animation_scale 0.0
    settings put global animator_duration_scale 0.0
    settings put global transition_animation_scale 0.0
    setprop persist.sys.ui.hw true
    busybox renice -10 $(busybox pgrep /system/bin/surfaceflinger)
    busybox renice -19 $(busybox pgrep /system/bin/onyx_tpd)
}

init_vm() {
    # Aggressive LMK:
    #echo "6400,7680,11520,25600,35840,38400" > /sys/module/lowmemorykiller/parameters/minfree
    # Default LMK:
    echo "12288,15360,18432,21504,24576,30720" > /sys/module/lowmemorykiller/parameters/minfree
    # start writing at 20 MB, don't buffer more than 100 MB:
    echo 2 > /proc/sys/vm/dirty_background_ratio
    echo 10 > /proc/sys/vm/dirty_ratio
    # instead of echo 1 > /proc/sys/vm/drop_caches
    #echo 1000 > /proc/sys/vm/vfs_cache_pressure
    # Default is 2884:
    echo 32768 > /proc/sys/vm/min_free_kbytes
    # Default is 60:
    #echo 0 > /proc/sys/vm/swappiness
    # seems to improve I/O performance
    #echo 1 > /proc/sys/vm/highmem_is_dirtyable
    # Default is cfq:
    echo "deadline" > /sys/block/mmcblk0/queue/scheduler
    # read ahead buffer size
    echo 1024 > /sys/block/mmcblk0/queue/read_ahead_kb
    if mount | grep -q /mnt/extsd
    then
        log "setting mmcblk1 queue parameters"
        echo "noop" > /sys/block/mmcblk1/queue/scheduler
        echo 1024 > /sys/block/mmcblk1/queue/read_ahead_kb
        busybox renice -15 $(busybox pgrep "mmcqd/1")
    fi
}

init_swap() {
    [ -e /cache/swap ] && grep -q /cache/swap /proc/swaps || swapon /cache/swap
    [ -e /data/swap ] && grep -q /data/swap /proc/swaps || swapon /data/swap
}

change_mode() {
    local mode
    mode=$1
    case "$2" in
    *SYSTEM\ POWER\ STATE:\ \[mem\]*)
        mode="mem"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[on\]*)
        mode="on"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[standby\]*)
        mode="standby"
        ;;
    esac
    echo $mode
}

is_blocked() {
    if [[ $time -le $block_time ]]
    then
        log "$((block_time-time)) s of blocking interval left"
        return 0
    else
        return 1
    fi
}

do_restart_power_service() {
    log "restart_power_service"
    stop power
    start power
    log "restart_power_service: exiting to induce restart"
    kill $keep_screen_responsive_pid
    kill $io_watchdog_pid
    exit 33
}

do_enter_suspend() {
    set_screenlock unlocked
    set_wakelock unlocked
    if [[ "$mode" == "standby" ]]
    then
        ( powerkey ; sleep 1 ; powerkey ) &
        block_time=$((time+60))
        log "enter_suspend ($mode): keep_screen_on-powerkey-sleep-powerkey, releasing wakelock, blocking for 60 s"
    else
        log "enter suspend ($mode): releasing wakelock"
    fi
}

do_sleep() {
    log "sleep: sleeping now ..."
    set_screenlock unlocked
}

do_wakeup() {
    log "wakeup: init_mixer, blocking for 15 s"
    init_mixer
    set_screenlock unlocked
    #check_governor performance
    refresh_screen
    block_time=$((time+15))
}

do_activity() {
    #touch /mnt/shm/sleepd_screenlock
    #check_governor auto
    #log "activity: governor=performance"
}

do_throttle() {
    #log "throttle: governor=auto"
    #check_governor auto
    #log "throttle: governor=performance regardless"
    #check_governor performance
}

do_refresh_screen() {
    refresh_screen
    log "refresh_screen, blocking for 2 s"
    block_time=$((time+2))
}

do_screenshot() {
    screencap -p /mnt/sdcard/Pictures/Screenshots/"$(date +"%Y-%m-%d_%H_%M_%S").png"
}

sleepd() {
    # ignore log up to $marker
    mode="on"
    while read line
    do
        mode=$(change_mode "$mode" "$line")
        [[ "$line" != "${line%$marker*}" ]] && break
    done

    refresh_screen
    log "Screen refresh to indicate sleepd start"

    # start reacting to messages
    time=${EPOCHREALTIME%%.*}
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    block_time=$((time+1))
    while read line
    do
        time=${EPOCHREALTIME%%.*}

        [[ "$mode" = "mem" ]] && tinymix "ClassD Speaker Control" Off

        # check for messages to react to
        case "$line" in
        */sleepd*)
            # Still in sync
            ping_time=$((time+60))
            ping_count=3
            continue  # loop, do not interpret own log messages
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            # First indicator of Onyx software starting to suspend the device
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *Go\ to\ Sleep\ as\ POWER\ key\ is\ pressed*)
            log "$line"
            is_blocked || do_enter_suspend
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            do_sleep
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            #log "$line"
            if [[ "$mode" = "mem" ]] && ! is_blocked
            then do_wakeup
            elif [[ "$mode" = "standby" ]] && ! is_blocked
            then do_activity
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            #log "$line"
            if [[ "$mode" = "mem" ]] && ! is_blocked
            then do_wakeup
            elif [[ "$mode" = "on" ]] && ! is_blocked
            then do_throttle
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[\]*)
            log "$line"
            #do_restart_power_service
            ;;
        *SYSTEM\ POWER\ STATE:*)
            log "$line"
            log "Unknown power state!"
            ;;
        *volume\ state\ changed\ for\ /storage/*\ mounted*)
            log "$line"
            init_vm
            ;;
        #*android.util.PhoneWindowHelper.onLongPress*)
        *android.hardware.DeviceController.sendOpenAndCloseFrontLightBroadcast*)
            do_screenshot
            ;;
        #*update_to_display*)
        #*handleInterceptActions:\ Waking\ up.*)
        esac

        mode=$(change_mode "$mode" "$line")

        # check if logcat - sleepd - logwrapper loop is still working
        if [[ $time -ge $ping_time ]] && [[ $ping_count -gt 0 ]]
        then
            echo >&2 "ping"
            ping_count=$((ping_count-1))
            ping_time=$((time+15))
            if [[ $ping_count = 0 ]]
            then
                exit_time=$((time+1))
            fi
        elif [[ $time -ge $exit_time ]]
        then
            log "unable to receive pings, exiting to induce restart"
            kill $keep_screen_responsive_pid
            kill $io_watchdog_pid
            exit 33
        fi
    done
}


marker="== started sleepd $$ at $(date) =="
log "$marker"

init_mixer
log "Set mixer defaults"

init_vm
log "Set defaults for vm management"

#settings put system screen_off_timeout 30000
#settings put system screen_off_timeout 300000
log "System's screen off timeout is set to $((0$(settings get system screen_off_timeout)/1000)) s"

#check_discard /storage/sdcard
#check_discard /mnt/extsd

#init_swap

# From Kernel 3.4 on ... setprop sys.sysctl.extra_free_kbytes 16384

init_screen
log "Set defaults for screen performance"

set_screenlock unlocked

keep_screen_responsive &
keep_screen_responsive_pid=$!

io_watchdog &
io_watchdog_pid=$!

log "Waiting for system to settle ..."
while [[ "0$(get_n_blocked)" -gt 0 ]]
do
    sleep 5
done

logcat -b system -b main -b events | sleepd

# * sys.onyx.pwrmode can be one of on/standby/mem
# * to test with adb running use "dumpsys battery set ac 0"
