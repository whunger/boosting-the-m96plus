#!/system/bin/sh

if [ -z "$1" ]
then
    while true
    do
        logwrapper "$0" wrapped
        rc=$?
        [ $rc != 33 ] && break
    done
    exit $rc
fi

log() {
    echo >&2 "$1"
    [ -e "/mnt/sdcard/sleepd.log" ] && echo "$(busybox date) $1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

get_uptime() {
    local uptime
    read uptime < /proc/uptime
    echo ${uptime%%.*}
}

get_n_blocked() {
    local label
    local v0
    local rest
    while read label v0 rest
    do
        if [ "$label" == "procs_blocked" ]
        then
            echo $v0
            break
        fi
    done < /proc/stat
}

check_governor() {
    local governor
    local target
    if [ "$1" == "auto" ]
    then
        if [ "$(get_n_blocked)" == "0" ]
        then
            target="ondemand"
        else
            target="performance"
        fi
    else
        target="$1"
    fi
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [ "$governor" != "$target" ]
    then
        echo "$target" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor to $target"
        return 0
    fi
    return 1
}

change_mode() {
    local mode
    mode=$1
    case "$2" in
    *SYSTEM\ POWER\ STATE:\ \[mem\]*)
        mode="mem"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[on\]*)
        mode="on"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[standby\]*)
        mode="standby"
        ;;
    esac
    echo $mode
}

check_discard() {
    for mp in /data /storage/sdcard /mnt/extsd
    do
        #[ -d "$mp" ] && /system/xbin/mount.static -o remount,discard "$mp"
        [ -d "$mp" ] && /system/bin/mount -o remount,discard "$mp"
    done
}

sleepd() {
    # ignore log up to $marker
    while read line
    do
        mode=$(change_mode "$mode" "$line")
        [ "$line" != "${line%$marker*}" ] && break
    done

    # start reacting to messages
    time=$(get_uptime)
    #last_line_ts=${line:0:14}  # 10-30 01:50:39
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    suspend_time=$((time+5))
    spkr_check_time=$((time-1))
    pwr_count=0
    if [ "$mode" = "mem" ]
    then
        sequence_start_time=$time
    else
        sequence_start_time=0
    fi
    while read line
    do
        time=$(get_uptime)
        #line_ts=${line:0:14}
        #if [ "$last_line_ts" != "$line_ts" ]
        #then
        #    last_line_ts=$line_ts
        #    ... do s.th. once per line_ts, e.g.
        #    time=$(get_uptime)
        #fi

        # check for speaker state, at most once per second
        if [ "$mode" != "on" ] && [ $time -gt $spkr_check_time ]
        then
            speaker_state=$(tinymix "ClassD Speaker Control")
            if [ "$speaker_state" == "${speaker_state%>Off*}" ]
            then
                tinymix "ClassD Speaker Control" Off &
                log "turning speaker off, current state is $speaker_state"
            fi
            spkr_check_time=$time
        fi

        # check for messages to react to
        trigger=""
        case "$line" in
        */sleepd*)
            # Still in sync
            ping_time=$((time+60))
            ping_count=3
            continue  # loop, do not interpret own log messages
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            trigger="enter_suspend"
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            # Real PWRBTN press by user? /!\
            log "$line"
            trigger="enter_suspend"
            ;;
        *Go\ to\ Sleep\ as\ POWER\ key\ is\ pressed*)
            log "$line"
            trigger="enter_suspend"
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            if [ $((time-sequence_start_time)) -lt 90 ] && [ $pwr_count = 0 ]
            then
                trigger="sleep"
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            log "$line"
            if [ $((time-sequence_start_time)) -lt 45 ] && [ $pwr_count = 1 ]
            then
                trigger="workaround_step_2"
            elif [ "$mode" = "mem" ]
            then
                trigger="wakeup"
            elif [ "$mode" = "standby" ]
            then
                trigger="activity"
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            log "$line"
            if [ "$mode" = "mem" ]
            then
                trigger="wakeup"
            elif [ "$mode" = "on" ]
            then
                trigger="throttle"
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[\]*)
            log "$line"
            trigger="restart_power_service"
            ;;
        *SYSTEM\ POWER\ STATE:*)
            log "$line"
            log "Unknown power state!"
            ;;
        *update_to_display*)
            check_governor performance && log "$line"
            ;;
        #*WindowManager\(*\):\ Window\ freeze\ timeout\ expired.*)
        #    log "$line"
        #    #trigger="refresh_screen"
        #    ;;
        #*showSystemImage:\ index:0*)
        #    log "$line"
        #    if [ $((time-sequence_start_time)) -lt 5 ] && [ $pwr_count = 2 ]
        #    then
        #        trigger="workaround_step_1"
        #    fi
        #    ;;
        #*showSystemImage:\ index:-1*)
        #    log "$line"
        #    #trigger="refresh_screen"
        #    ;;
        #*handleInterceptActions:\ Waking\ up*)
        #    log "$line"
        #    #trigger="wakeup"
        #    ;;
        #*Going\ to\ sleep\ due\ to\ screen\ timeout...*)
        #    log "$line"
        #    #trigger="enter_suspend"
        #    ;;
        #*Unblocked\ screen\ on\ after*)
        #    log "$line"
        #    _trigger="wakeup"
        #    ;;
        #*Excessive\ delay*while\ turning\ screen\ on*)
        #    log "$line"
        #    #trigger="refresh_screen"
        #    ;;
        #*Excessive\ delay*)
        #    log "$line"
        #    ;;
        #*Going\ to\ sleep*)
        #    log "$line"
        #    ;;
        #*showSystemImage:*)
        #    log "$line"
        #    ;;
        #*handleInterceptActions:*)
        #    log "$line"
        #    ;;
        #*screen*)
        #    log "$line"
        #    ;;
        #*Power*)
        #    log "$line"
        #    ;;
        #*power*)
        #    log "$line"
        #    ;;
        #*POWER*)
        #    log "$line"
        #    ;;
        esac

        # reactors
        if [ -n "$trigger" ]
        then
            if [ "$trigger" = "restart_power_service" ]
            then
                log "restarting power service"
                stop power
                start power
                log "exiting to induce restart"
                exit 33
            #elif [ "$trigger" = "workaround_step_1" ]
            #then
            #    powerkey
            #    log "$trigger: powerkey ($pwr_count)"
            #    pwr_count=$((pwr_count-1))
            elif [ "$trigger" = "workaround_step_2" ]
            then
                (am broadcast -a refresh_screen ; powerkey) &
                pwr_count=$((pwr_count-1))
                log "$trigger: refresh_screen + powerkey ($pwr_count)"
            elif [ "$trigger" = "sleep" ]
            then
                log "$trigger: sleeping now ..."
                sequence_start_time=0
            elif [ "$trigger" = "wakeup" ]
            then
                log "$trigger: governor=performance, suspend for 15 s, refresh_screen, check_discard, restart power service, speaker off"
                check_governor performance
                sequence_start_time=0
                suspend_time=$((time+5))
                am broadcast -a refresh_screen &
                check_discard
            elif [ -n "$trigger" ] && [ $time -le $suspend_time ]
            then
                log "$trigger: ignored due to suspend time: $((suspend_time-time)) s left"
            elif [ "$trigger" = "enter_suspend" ] && [ $sequence_start_time = 0 ]
            then
                powerkey &
                pwr_count=1  # one more
                check_governor performance
                (am broadcast -a refresh_screen ; powerkey) &
                log "$trigger: powerkey, governor=performance, refresh_screen, suspend for 30 s"
                sequence_start_time=$time
                suspend_time=$((time+30))
            elif [ "$trigger" = "refresh_screen" ]
            then
                am broadcast -a refresh_screen &
                log "$trigger: refresh_screen, suspend for 5 s"
                suspend_time=$((time+5))
            elif [ "$trigger" = "activity" ]
            then
                log "$trigger: governor=performance"
                check_governor performance
            elif [ "$trigger" = "throttle" ]
            then
                log "$trigger: governor=auto"
                check_governor auto
            elif [ -n "$trigger" ]
            then
                log "$trigger: ignored, delta suspend=$((suspend_time-time)), mode=$mode, delta seq start=$((time-sequence_start_time))"
            fi
        fi
        
        mode=$(change_mode "$mode" "$line")

        # check if logcat - sleepd - logwrapper loop is still working
        if [ $time -ge $ping_time ] && [ $ping_count -gt 0 ]
        then
            #log "ping"
            echo >&2 "ping"
            ping_count=$((ping_count-1))
            ping_time=$((time+5))
            if [ $ping_count = 0 ]
            then
                exit_time=$((time+1))
            fi
        elif [ $time -ge $exit_time ]
        then
            log "exiting to induce restart"
            exit 33
        fi
    done
}


marker="== started sleepd $$ at $(busybox date) =="
log "$marker"

#busybox renice -10 $$
#log "Increased priority of sleepd"

#setprop sys.interactive active
#log "setprop sys.interactive active"

echo 1000000 > /sys/power/device_suspend_time_threshold
log "Increased device_suspend_time_threshold=$(cat /sys/power/device_suspend_time_threshold)"

#busybox renice 19 $(busybox pgrep "mmcqd/1")

# Testing: Can we do s.th. against loudspeaker pops?
tinymix "Capture Volume" 0
tinymix "Right Output Mixer Boost Bypass Switch" 1
tinymix "Left Output Mixer Boost Bypass Switch" 1
tinymix "Speaker Playback ZC Switch" 1 1

# 10	INT	2	Speaker Playback Volume                  0 0
#     0 .. 127
# 11	BOOL	2	Speaker Playback ZC Switch               Off Off
#     1 = Change gain on zero cross only 
#     0 = Change gain immediately 
# 12	INT	1	Speaker DC Volume                        0
# 13	INT	1	Speaker AC Volume                        0
# 38	ENUM	1	ClassD Speaker Control                   Both
#     Off Left Right Both
#     00 = Off 
#     01 = Left speaker only 
#     10 = Right speaker only 
#     11 = Left and right speakers enabled 
# 42	BOOL	1	Right Output Mixer PCM Playback Switch   On
# 43	BOOL	1	Right Output Mixer RINPUT3 Switch        Off
# 44	BOOL	1	Right Output Mixer Boost Bypass Switch   Off
# 45	BOOL	1	Left Output Mixer PCM Playback Switch    On
# 46	BOOL	1	Left Output Mixer LINPUT3 Switch         Off
# 47	BOOL	1	Left Output Mixer Boost Bypass Switch    Off

#settings put system screen_off_timeout 30000
log "System's screen off timeout is set to $(($(settings get system screen_off_timeout)/1000)) s"

log "Making sure discard is enabled for data partitions ..."
check_discard

logcat -b system -b main -b events | sleepd

# Todo: React to these by waking the device up?
#10-03 20:06:01.070 D/InputManager-JNI( 2371): handleInterceptActions: Waking up.
#10-03 20:06:01.090 I/InputDispatcher( 2371): Dropped event because input dispatch is disabled.
#10-03 20:06:01.090 D/pms     ( 2371): userActivityNoUpdateLocked: reject all events except the POWER/FORCE_WAKEUP key
#10-15 09:30:04.330 W/audio_hw_primary( 2017): set parameters screen_state=off
#Screen released, type=0 flinger=0x410d0690
#screen update disabled

# Can refresh help to force wallpaper display?

# No use: Fixing brightness with
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/actual_brightness
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness
