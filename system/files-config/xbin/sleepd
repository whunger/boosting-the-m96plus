#!/system/bin/sh

if [ -z "$1" ]
then
    while true
    do
        /system/bin/logwrapper "$0" wrapped
        rc=$?
        [ $rc != 33 ] && break
    done
    exit $rc
fi

log() {
    echo >&2 "$1"
    [ -e "/mnt/sdcard/sleepd.log" ] && echo "$(/system/bin/busybox date) $1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar /system/bin/app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar /system/bin/app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar /system/bin/app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

get_uptime() {
    local uptime
    read uptime < /proc/uptime
    echo ${uptime%%.*}
}

get_n_blocked() {
    local label
    local v0
    local rest
    while read label v0 rest
    do
        if [ "$label" == "procs_blocked" ]
        then
            echo $v0
            break
        fi
    done < /proc/stat
}

check_governor() {
    local governor
    local target
    if [ "$1" == "auto" ]
    then
        if [ "$(get_n_blocked)" == "0" ]
        then
            target="interactive"
        else
            target="performance"
        fi
    else
        target="$1"
    fi
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [ "$governor" != "$target" ]
    then
        echo "$target" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor to $target"
        return 0
    fi
    return 1
}

change_mode() {
    local mode
    mode=$1
    case "$2" in
    *SYSTEM\ POWER\ STATE:\ \[mem\]*)
        mode="mem"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[on\]*)
        mode="on"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[standby\]*)
        mode="standby"
        ;;
    esac
    echo $mode
}

sleepd() {
    # ignore log up to $marker
    while read line
    do
        mode=$(change_mode "$mode" "$line")
        [ "$line" != "${line%$marker*}" ] && break
    done

    # start reacting to messages
    time=$(get_uptime)
    last_line_ts=${line:0:14}  # 10-30 01:50:39
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    suspend_time=$((time+5))
    state=0  # state for simulated PWRBTN presses
    if [ $mode = "mem" ]
    then
        sequence_start_time=$time
    else
        sequence_start_time=0
    fi
    while read line
    do
        line_ts=${line:0:14}
        if [ "$last_line_ts" != "$line_ts" ]
        then
            time=$(get_uptime)
            last_line_ts=$line_ts
        fi
        # check for messages to react to
        trigger=""
        case "$line" in
        */sleepd*)
            # Still in sync
            ping_time=$((time+60))
            ping_count=3
            continue  # loop, do not interpret own log messages
            ;;
        *WindowManager\(*\):\ Window\ freeze\ timeout\ expired.*)
            log "$line"
            #trigger="refresh_screen"
            ;;
        *showSystemImage:\ index:-1*)
            log "$line"
            #trigger="refresh_screen"
            ;;
        *showSystemImage:\ index:0*)
            log "$line"
            trigger="show_wallpaper"
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            trigger="enter_suspend"
            ;;
        *handleInterceptActions:\ Waking\ up*)
            log "$line"
            #trigger="wakeup"
            ;;
        *handleInterceptActions:\ Not\ passing\ key\ to\ user*)
            log "$line"
            #trigger="enter_suspend"
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            log "$line"
            trigger="enter_suspend"
            ;;
        *Go\ to\ Sleep\ as\ POWER\ key\ is\ pressed*)
            log "$line"
            trigger="enter_suspend"
            ;;
        *Going\ to\ sleep\ due\ to\ screen\ timeout...*)
            log "$line"
            #trigger="enter_suspend"
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            trigger="sleep"
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            log "$line"
            trigger="wakeup_or_sleep"
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            log "$line"
            trigger="throttle"
            ;;
        *SYSTEM\ POWER\ STATE:\ \[\]*)
            log "$line"
            trigger="restart_power_service"
            ;;
        *SYSTEM\ POWER\ STATE:*)
            log "$line"
            log "Unknown power state!"
            ;;
        *Excessive\ delay*while\ turning\ screen\ on*)
            log "$line"
            #trigger="refresh_screen"
            ;;
        *Excessive\ delay*)
            log "$line"
            ;;
        *Going\ to\ sleep*)
            log "$line"
            ;;
        *showSystemImage:*)
            log "$line"
            ;;
        *handleInterceptActions:*)
            log "$line"
            ;;
        *screen*)
            log "$line"
            ;;
        *Power*)
            log "$line"
            ;;
        *power*)
            log "$line"
            ;;
        *POWER*)
            log "$line"
            ;;
        *update_to_display*)
            check_governor performance && log "$line"
            ;;
        esac

        # state maintenance
        #if [ $state -gt 1 ] && [ $state -lt 4 ] && [ $((time-sequence_start_time)) -gt 150 ]
        #then
        #    state=0
        #    log "reset state to 0 because workaround sequence start is too long ago"
        #fi

        # reactors
        if [ "$trigger" = "restart_power_service" ]
        then
            log "restarting power service"
            stop power
            start power
            log "exiting to induce restart"
            exit 33
        elif [ "$trigger" = "refresh_screen" ] && [ $time -gt $suspend_time ] && [ $mode != "mem" ]
        then
            am broadcast -a refresh_screen &
            log "$trigger: refresh_screen, suspend for 5 s"
            suspend_time=$((time+5))
            state=0
        elif [ "$trigger" = "enter_suspend" ] && [ $time -gt $suspend_time ] && [ $sequence_start_time = 0 ]
        then
            check_governor performance
            # Try to get rid of pops:
            /system/bin/tinymix "Playback Volume" 0
            log "$trigger: governor=performance, volume=0, state=1, suspend for 30 s"
            state=1
            suspend_time=$((time+30))
            sequence_start_time=$time
        elif [ "$trigger" = "show_wallpaper" ] && [ $((time-sequence_start_time)) -lt 5 ]
        then
            powerkey &
            log "$trigger: powerkey (1), state=2"
            state=2
        elif [ "$trigger" = "wakeup_or_sleep" ] && [ $((time-sequence_start_time)) -lt 45 ]
        then
            (am broadcast -a refresh_screen ; powerkey) &
            log "$trigger: refresh_screen + powerkey (2), state=3"
            state=3
        elif [ "$trigger" = "sleep" ] && [ $((time-sequence_start_time)) -lt 90 ]
        then
            log "$trigger: state=4, sleeping now ..."
            state=4  # time to do nothing, at last
        elif [ "$trigger" = "wakeup_or_sleep" ] && [ $sequence_start_time -gt 0 ]
        then
            log "$trigger: wakeup, governor=performance, volume restore, state=0, suspend for 5 s, refresh_screen"
            check_governor performance
            # Restore volume
            /system/bin/tinymix "Playback Volume" 250
            state=0
            sequence_start_time=0
            suspend_time=$((time+5))
            am broadcast -a refresh_screen &
        elif [ "$trigger" = "wakeup_or_sleep" ] && [ $sequence_start_time = 0 ]
        then
            log "$trigger: governor=performance"
            check_governor performance
        elif [ "$trigger" = "throttle" ] && [ $sequence_start_time = 0 ]
        then
            log "throttle: governor=auto"
            check_governor auto
        elif [ -n "$trigger" ]
        then
            log "$trigger: ignored, state=$state, dsuspend=$((suspend_time-time)), mode=$mode, dsst=$((time-sequence_start_time))"
        fi

        mode=$(change_mode "$mode" "$line")

        # check if logcat - sleepd - logwrapper loop is still working
        if [ $time -ge $ping_time ] && [ $ping_count -gt 0 ]
        then
            log "ping"
            #echo >&2 "ping"
            ping_count=$((ping_count-1))
            ping_time=$((time+5))
            if [ $ping_count = 0 ]
            then
                exit_time=$((time+1))
            fi
        elif [ $time -ge $exit_time ]
        then
            log "exiting to induce restart"
            exit 33
        fi
    done
}


marker="== started sleepd $$ at $(busybox date) =="
log "$marker"

#/system/bin/busybox renice -10 $$
echo 400000 > /sys/power/device_suspend_time_threshold
/system/bin/busybox renice 19 $(/system/bin/busybox pgrep "mmcqd/1")

# Testing: Can we do s.th. against loudspeaker pops?
/system/bin/tinymix "Capture Volume" 0
/system/bin/tinymix "Right Boost Mixer RINPUT1 Switch" 0
/system/bin/tinymix "Left Boost Mixer LINPUT1 Switch" 0

#settings put system screen_off_timeout 30000
log "System's screen off timeout is set to $(($(settings get system screen_off_timeout)/1000)) s"

/system/bin/logcat -b system -b main -b events | sleepd

# Todo: React to these by waking the device up?
#10-03 20:06:01.070 D/InputManager-JNI( 2371): handleInterceptActions: Waking up.
#10-03 20:06:01.090 I/InputDispatcher( 2371): Dropped event because input dispatch is disabled.
#10-03 20:06:01.090 D/pms     ( 2371): userActivityNoUpdateLocked: reject all events except the POWER/FORCE_WAKEUP key
#10-15 09:30:04.330 W/audio_hw_primary( 2017): set parameters screen_state=off
#Screen released, type=0 flinger=0x410d0690
#screen update disabled

# Can refresh help to force wallpaper display?

# No use: Fixing brightness with
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/actual_brightness
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness
