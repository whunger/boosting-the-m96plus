#!/system/bin/sh

if [[ -z "$1" ]]
then
    while true
    do
        logwrapper "$0" wrapped
        rc=$?
        [[ $rc != 33 ]] && break
    done
    exit $rc
fi

log() {
    echo >&2 "$1"
    [[ -e "/mnt/sdcard/sleepd.log" ]] && echo "$(busybox date) $1" >> /mnt/sdcard/sleepd.log
}

am() {
    CLASSPATH=/system/framework/am.jar app_process /system/bin com.android.commands.am.Am "$@"
}

settings() {
    CLASSPATH=/system/framework/settings.jar app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

powerkey() {
    CLASSPATH=/system/framework/input.jar app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

get_n_blocked() {
    local label
    local v0
    local rest
    while read label v0 rest
    do
        if [[ "$label" == "procs_blocked" ]]
        then
            echo $v0
            break
        fi
    done < /proc/stat
}

check_governor() {
    local governor
    local target
    if [[ "$1" == "auto" ]]
    then
        if [[ "$(get_n_blocked)" == "0" ]]
        then
            target="ondemand"
        else
            target="performance"
        fi
    else
        target="$1"
    fi
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    if [[ "$governor" != "$target" ]]
    then
        echo "$target" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        log "set governor to $target"
        return 0
    fi
    return 1
}

change_mode() {
    local mode
    mode=$1
    case "$2" in
    *SYSTEM\ POWER\ STATE:\ \[mem\]*)
        mode="mem"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[on\]*)
        mode="on"
        ;;
    *SYSTEM\ POWER\ STATE:\ \[standby\]*)
        mode="standby"
        ;;
    esac
    echo $mode
}

check_discard() {
    log "mount -o remount,discard,noatime /data"
    mount -o remount,discard,noatime /data
    for mp in /storage/sdcard /mnt/extsd
    do
        #log "/system/xbin/mount.static -o remount,discard,noatime,norelatime $mp"
        #[ -d "$mp" ] && /system/xbin/mount.static -o remount,discard,noatime,norelatime "$mp"
        log "mount -o remount,discard,noatime,norelatime $mp"
        [[ -d "$mp" ]] && mount -o remount,discard,noatime,norelatime "$mp"
    done
}

is_blocked() {
    if [[ $time -le $block_time ]]
    then
        log "$((block_time-time)) s of blocking interval left"
        return 0
    else
        return 1
    fi
}

do_restart_power_service() {
    log "restart_power_service"
    stop power
    start power
    log "restart_power_service: exiting to induce restart"
    exit 33
}

do_enter_suspend() {
    #( am broadcast -a refresh_screen ; powerkey ; sleep 0.1 ; powerkey ) &
    #log "enter_suspend: refresh_screen-powerkey-sleep-powerkey, blocking for 10 s"
    ( powerkey ; sleep 0.1 ; powerkey ) &
    log "enter_suspend: powerkey-sleep-powerkey, blocking for 30 s"
    #sequence_start_time=$time
    #workaround=1
    block_time=$((time+30))
}

#do_workaround() {
#    powerkey
#    log "workaround: powerkey"
#}

#do_suspend() {
#    powerkey
#    log "suspend: powerkey, workaround=0, blocking for 10 s"
#    workaround=0
#    block_time=$((time+10))
#}

do_sleep() {
    log "sleep: sleeping now ..."
    #sequence_start_time=0
}

do_wakeup() {
    log "wakeup: governor=performance, refresh_screen, check_discard, speaker zero crossing switch, blocking for 15 s"
    check_governor performance
    am broadcast -a refresh_screen
    check_discard
    tinymix "Speaker Playback ZC Switch" 1 1
    #sequence_start_time=0
    #workaround=0
    block_time=$((time+15))
}

do_activity() {
    log "activity: governor=performance"
    check_governor performance
}

do_throttle() {
    log "throttle: governor=auto"
    check_governor auto
}

do_refresh_screen() {
    am broadcast -a refresh_screen &
    log "refresh_screen"
}

sleepd() {
    # ignore log up to $marker
    while read line
    do
        mode=$(change_mode "$mode" "$line")
        [[ "$line" != "${line%$marker*}" ]] && break
    done

    # start reacting to messages
    time=${EPOCHREALTIME%%.*}
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    block_time=$((time+1))
    spkr_check_time=$((time-1))
    #workaround=0
    #if [[ "$mode" = "mem" ]]
    #then
    #    sequence_start_time=$time
    #else
    #    sequence_start_time=0
    #fi
    while read line
    do
        time=${EPOCHREALTIME%%.*}

        # check for speaker state, at most once per second
        if [[ "$mode" != "on" ]] && [[ $time -gt $spkr_check_time ]]
        then
            #speaker_state=$(tinymix "ClassD Speaker Control")
            #if [ "$speaker_state" == "${speaker_state%>Off*}" ]
            #then
            #    tinymix "ClassD Speaker Control" Off &
            #    log "turning speaker off, current state is $speaker_state"
            #fi
            # Just turn it off
            tinymix "ClassD Speaker Control" Off
            spkr_check_time=$time
        fi

        # check for messages to react to
        case "$line" in
        */sleepd*)
            # Still in sync
            ping_time=$((time+60))
            ping_count=3
            continue  # loop, do not interpret own log messages
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            #if [[ $sequence_start_time = 0 ]] && ! is_blocked
            if ! is_blocked
            then do_enter_suspend
            fi
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            # Real PWRBTN press by user? /!\
            log "$line"
            #if [[ $sequence_start_time = 0 ]] && ! is_blocked
            if ! is_blocked
            then do_enter_suspend
            fi
            ;;
        *Go\ to\ Sleep\ as\ POWER\ key\ is\ pressed*)
            log "$line"
            #if [[ $sequence_start_time = 0 ]] && ! is_blocked
            if ! is_blocked
            then do_enter_suspend
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            log "$line"
            do_sleep
            #if [[ $workaround = 1 ]]
            #then
            #    if [[ $((time-sequence_start_time)) -lt 90 ]]
            #    then do_workaround
            #    else workaround=0
            #    fi
            #else do_sleep
            #fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            log "$line"
            #if [[ $workaround = 1 ]]
            #then
            #    if [[ $((time-sequence_start_time)) -lt 90 ]]
            #    then do_suspend
            #    else workaround=0
            #    fi
            #el
            if [[ "$mode" = "mem" ]]
            then do_wakeup
            elif [[ "$mode" = "standby" ]] && ! is_blocked
            then do_activity
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            log "$line"
            if [[ "$mode" = "mem" ]]
            then do_wakeup
            elif [[ "$mode" = "on" ]] && ! is_blocked
            then do_throttle
            fi
            ;;
        *SYSTEM\ POWER\ STATE:\ \[\]*)
            log "$line"
            do_restart_power_service
            ;;
        *SYSTEM\ POWER\ STATE:*)
            log "$line"
            log "Unknown power state!"
            ;;
        *update_to_display*)
            check_governor performance && log "$line"
            ;;
        *WindowManager\(*\):\ Window\ freeze\ timeout\ expired.*)
            log "$line"
            ;;
        #*showSystemImage:\ index:0*)
        #    log "$line"
        #    if [ $((time-sequence_start_time)) -lt 5 ] && [ $pwr_count = 2 ]
        #    then
        #        trigger="workaround_step_1"
        #    fi
        #    ;;
        #*showSystemImage:\ index:-1*)
        #    log "$line"
        #    #trigger="refresh_screen"
        #    ;;
        #*Going\ to\ sleep\ due\ to\ screen\ timeout...*)
        #    log "$line"
        #    trigger="enter_suspend"
        #    ;;
        #*handleInterceptActions:\ Waking\ up*)
        #    log "$line"
        #    #trigger="wakeup"
        #    ;;
        #*Unblocked\ screen\ on\ after*)
        #    log "$line"
        #    _trigger="wakeup"
        #    ;;
        #*Excessive\ delay*while\ turning\ screen\ on*)
        #    log "$line"
        #    #trigger="refresh_screen"
        #    ;;
        *Excessive\ delay*)
            log "$line"
            ;;
        #*Going\ to\ sleep*)
        #    log "$line"
        #    ;;
        #*showSystemImage:*)
        #    log "$line"
        #    ;;
        #*handleInterceptActions:*)
        #    log "$line"
        #    ;;
        #*screen*)
        #    log "$line"
        #    ;;
        #*Power*)
        #    log "$line"
        #    ;;
        #*power*)
        #    log "$line"
        #    ;;
        #*POWER*)
        #    log "$line"
        #    ;;
        esac

        mode=$(change_mode "$mode" "$line")

        # check if logcat - sleepd - logwrapper loop is still working
        if [[ $time -ge $ping_time ]] && [[ $ping_count -gt 0 ]]
        then
            #log "ping"
            echo >&2 "ping"
            ping_count=$((ping_count-1))
            ping_time=$((time+5))
            if [[ $ping_count = 0 ]]
            then
                exit_time=$((time+1))
            fi
        elif [[ $time -ge $exit_time ]]
        then
            log "exiting to induce restart"
            exit 33
        fi
    done
}


marker="== started sleepd $$ at $(busybox date) =="
log "$marker"

#busybox renice -10 $$
#log "Increased priority of sleepd"

#setprop sys.interactive active
#log "setprop sys.interactive active"

echo 1000000 > /sys/power/device_suspend_time_threshold
log "Increased device_suspend_time_threshold=$(cat /sys/power/device_suspend_time_threshold)"

# faster I/O? From https://sites.google.com/site/tweakradje/android/android-tweaking
# might trigger OOM killer
echo 1 > /proc/sys/vm/highmem_is_dirtyable
log "Set /proc/sys/vm/highmem_is_dirtyable=1"

stop netmgrd
stop qmuxd
stop ril-daemon
log "Stopped telephony services"

#busybox renice 19 $(busybox pgrep "mmcqd/1")

# Testing: Can we do s.th. against loudspeaker pops?
tinymix "Capture Volume" 0
tinymix "Right Output Mixer Boost Bypass Switch" 1
tinymix "Left Output Mixer Boost Bypass Switch" 1
tinymix "Speaker Playback ZC Switch" 1 1

# 10	INT	2	Speaker Playback Volume                  0 0
#     0 .. 127
# 11	BOOL	2	Speaker Playback ZC Switch               Off Off
#     1 = Change gain on zero cross only 
#     0 = Change gain immediately 
# 12	INT	1	Speaker DC Volume                        0
# 13	INT	1	Speaker AC Volume                        0
# 38	ENUM	1	ClassD Speaker Control                   Both
#     Off Left Right Both
#     00 = Off 
#     01 = Left speaker only 
#     10 = Right speaker only 
#     11 = Left and right speakers enabled 
# 42	BOOL	1	Right Output Mixer PCM Playback Switch   On
# 43	BOOL	1	Right Output Mixer RINPUT3 Switch        Off
# 44	BOOL	1	Right Output Mixer Boost Bypass Switch   Off
# 45	BOOL	1	Left Output Mixer PCM Playback Switch    On
# 46	BOOL	1	Left Output Mixer LINPUT3 Switch         Off
# 47	BOOL	1	Left Output Mixer Boost Bypass Switch    Off

#settings put system screen_off_timeout 30000
log "System's screen off timeout is set to $(($(settings get system screen_off_timeout)/1000)) s"

log "Making sure discard is enabled for data partitions ..."
check_discard

logcat -b system -b main -b events | sleepd

# Todo: React to these by waking the device up?
#10-03 20:06:01.070 D/InputManager-JNI( 2371): handleInterceptActions: Waking up.
#10-03 20:06:01.090 I/InputDispatcher( 2371): Dropped event because input dispatch is disabled.
#10-03 20:06:01.090 D/pms     ( 2371): userActivityNoUpdateLocked: reject all events except the POWER/FORCE_WAKEUP key
#10-15 09:30:04.330 W/audio_hw_primary( 2017): set parameters screen_state=off
#Screen released, type=0 flinger=0x410d0690
#screen update disabled

# Can refresh help to force wallpaper display?

# No use: Fixing brightness with
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/actual_brightness
# /sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness
