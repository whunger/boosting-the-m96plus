go_to_sleep() {
    /system/bin/busybox sleep 30
    CLASSPATH=/system/framework/input.jar /system/bin/app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
    /system/bin/busybox sleep 0.5
    CLASSPATH=/system/framework/input.jar /system/bin/app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
    /system/bin/busybox sleep 0.5
    CLASSPATH=/system/framework/input.jar /system/bin/app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

sleepd2() {
    # ignore log up to $marker
    while read line
    do
        [ "$line" != "${line%$marker*}" ] && break
    done

    # start reacting to messages
    time=$(get_uptime)
    ping_time=$((time+60))
    ping_count=0
    exit_time=$((time+3600*24))
    timeout_pid=""
    while read line
    do
        # check if logcat - sleepd - logwrapper loop is still working
        time=$(get_uptime)
        case "$line" in
        */sleepd*)
            ping_time=$((time+60))
            ping_count=2
            ;;
        *)
            if [ $time -ge $ping_time ] && [ $ping_count -gt 0 ]
            then
                log "ping"
                #echo >&2 "ping"
                ping_count=$((ping_count-1))
                ping_time=$((time+5))
                if [ $ping_count = 0 ]
                then
                    exit_time=$((time+1))
                fi
            elif [ $time -ge $exit_time ]
            then
                log "exiting to induce restart"
                exit 33
            fi
            ;;
        esac
        # check for messages to react to
        kill_timeout=0
        case "$line" in
        */sleepd*)
            continue  # ignore own messages
            ;;
        *WindowManager\(*\):\ Window\ freeze\ timeout\ expired.*)
            log "$line"
            am broadcast -a refresh_screen
            log "refresh_screen requested"
            ;;
        *SYSTEM\ POWER\ STATE:\ \[on\]*)
            kill_timeout=1
            check_governor interactive
            # Try to get rid of pops:
            /system/bin/tinymix "Playback Volume" 0
            ;;
        *SYSTEM\ POWER\ STATE:\ \[mem\]*)
            kill_timeout=1
            # Try to get rid of pops:
            /system/bin/tinymix "Playback Volume" 250
            ;;
        *SYSTEM\ POWER\ STATE:\ \[standby\]*)
            log "$line"
            go_to_sleep &
            timeout_pid=$!
            log "started $timeout_pid"
            check_governor interactive
            # Try to get rid of pops:
            /system/bin/tinymix "Playback Volume" 250
            ;;
        *audio_hw_primary*set\ parameters\ screen_state=off*)
            log "$line"
            # Try to get rid of pops:
            /system/bin/tinymix "Playback Volume" 0
            ;;
        *update_to_display*)
            check_governor performance && log "$line"
            ;;
        *showSystemImage:\ index:0*)
            log "$line"
            ;;
        *updatePowerState:\ Found\ IDLE\ transfer\ to\ MEM\ state*)
            log "$line"
            ;;
        *handleInterceptActions:\ Not\ passing\ key\ to\ user*)
            log "$line"
            ;;
        *Going\ to\ sleep\ by\ user\ request...*)
            log "$line"
            ;;
        *Going\ to\ sleep\ due\ to\ screen\ timeout...*)
            log "$line"
            ;;
        *Excessive\ delay*)
            log "$line"
            ;;
        *Going\ to\ sleep*)
            log "$line"
            ;;
        *showSystemImage:*)
            log "$line"
            ;;
        *handleInterceptActions:*)
            log "$line"
            ;;
        *screen*)
            log "$line"
            ;;
        *Power*)
            log "$line"
            ;;
        *power*)
            log "$line"
            ;;
        *POWER*)
            log "$line"
            ;;
        esac
        if [ $kill_timeout = 1 ]
        then
            log "$line"
            kill_timeout=0
            if [ -n "$timeout_pid" ]
            then
                /system/bin/busybox kill $timeout_pid
                log "killed $timeout_pid"
                timeout_pid=""
            fi
        fi
    done
}

