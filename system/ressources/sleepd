#!/system/bin/sh
#
# Standby/suspend helper daemon
#
# * detect user inactivity from /proc/interrupts
# * detect power button presses from /proc/interrupts
# * the Hanvon pen is connected to the 2nd uart (IRQ 59)
# * buttons are connected to GPIO pins
#
#  59:     115712       GIC  IMX-uart
#  87:      63859       GIC  i.MX Timer Tick
# 338:          0      GPIO  btn power
# 344:         10      GPIO  btn 4K_pgdn
# 345:         14      GPIO  btn 5K_left
# 346:          8      GPIO  btn 4K_pgup
# 347:         26      GPIO  btn 5K_right
# 348:          6      GPIO  btn 4K_menu
# 349:          4      GPIO  btn 5K_ok
# 350:         10      GPIO  btn 4K_back
# 351:         36      GPIO  btn 5K_up
# 352:          2      GPIO  btn VOL_UP
# 353:         80      GPIO  btn 5K_down
# 354:          4      GPIO  btn VOL_DOWN
#
# * sys.onyx.pwrmode can be one of on/standby/mem
# * to test with adb running use "dumpsys battery set ac 0"
#

get_activity_counts() {
    local irq
    local n
    local type
    local name
    count_pen=0
    count_btn=0
    count_pwr=0
    while read irq n type name
    do
        if [ "$irq" = "59:" ]
        then
            count_pen=$n
        elif [ "$name" = "btn power" ]
        then
            count_pwr=$n
        elif [ "${name:0:3}" = "btn" ]
        then
            let count_btn=count_btn+n
        fi
    done < /proc/interrupts
}

get_uptime() {
    read uptime idle < /proc/uptime
    /system/bin/busybox printf "%.0f" $uptime
}

powerkey() {
    echo "[powerkey]"
    CLASSPATH=/system/framework/input.jar /system/bin/app_process /system/bin com.android.commands.input.Input keyevent KEYCODE_POWER
}

svc() {
    CLASSPATH=/system/framework/svc.jar /system/bin/app_process /system/bin com.android.commands.svc.Svc $*
}

settings() {
    CLASSPATH=/system/framework/settings.jar /system/bin/app_process /system/bin com.android.commands.settings.SettingsCmd "$@"
}

am() {
    CLASSPATH=/system/framework/am.jar /system/bin/app_process /system/bin com.android.commands.am.Am "$@"
}

read_config() {
    if [ -e /mnt/sdcard/sleep.cfg ]
    then
        read timeout < /mnt/sdcard/sleep.cfg
        echo "set activity timeout to $timeout s from sleep.cfg"
    else
        let timeout=$(settings get system screen_off_timeout)/1000
        echo "set activity timeout to $timeout s from system settings"
    fi
}

wait_for_mode() {
    local pwrmode
    echo "waiting for mode $1 ..."
    pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
    while [ "$pwrmode" != "$1" ]
    do
        sleep 0.2
        pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
    done
}

do_wake() {
    local pwrmode
    powerkey
    /system/bin/sleep 0.1
    pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
    if [ "$pwrmode" != "on" ]
    then
        echo waiting for power ...
        while [ "$pwrmode" != "on" ]
        do
            echo "retrying ..."
            powerkey
            /system/bin/sleep 2
            pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
        done
    fi
}

read_config
get_activity_counts

request="none"
pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
last_activity_ts=$(get_uptime)
last_btn_ts=$last_activity_ts
last_pen_ts=$last_activity_ts
last_pwr_btn_ts=$last_activity_ts
last_request_ts=$last_activity_ts
last_wakeup_ts=$last_activity_ts
last_sleep_ts=$last_activity_ts

#echo sleepd > /sys/power/wake_lock
echo 250000 > /sys/power/device_suspend_time_threshold
svc power stayon true

while true
do
    last_pwrmode=$pwrmode
    pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
    read governor < /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    uptime=$(get_uptime)
    echo "pwrmode is $last_pwrmode -> $pwrmode, governor is $governor"
    if [ "$request" != "none" ]
    then
        last_request_ts=$uptime
        request="none"
    fi
    
    if [ "$last_pwrmode" = "mem" -a "$pwrmode" != "mem" ]
    then
        echo "wakeup detected"
        last_wakeup_ts=$uptime
        last_activity_ts=$uptime
    fi
    let wakeup_recency=uptime-last_wakeup_ts

    if [ "$last_pwrmode" != "mem" -a "$pwrmode" = "mem" ]
    then
        echo "sleep detected"
        last_sleep_ts=$uptime
    fi
    let sleep_recency=uptime-last_sleep_ts

    count_btn_prv=$count_btn
    count_pen_prv=$count_pen
    count_pwr_prv=$count_pwr
    get_activity_counts
    if [ $count_btn -gt $count_btn_prv ]
    then
        let d=count_btn-count_btn_prv
        echo "button input activity detected: d=$d"
        last_btn_ts=$uptime
        last_activity_ts=$uptime
    fi
    if [ $count_pen -gt $count_pen_prv ]
    then
        let d=count_pen-count_pen_prv
        echo "pen input activity detected: d=$d"
        if [ $d -gt 200 ]
        then
            last_pen_ts=$uptime
            last_activity_ts=$uptime
        fi
    fi
    if [ $count_pwr -gt $count_pwr_prv ]
    then
        let d=count_pwr-count_pwr_prv
        echo "power button press detected: d=$d"
        last_pwr_btn_ts=$uptime
        last_activity_ts=$uptime
    fi
    let recency=uptime-last_activity_ts
    let pen_recency=uptime-last_pen_ts
    let btn_recency=uptime-last_btn_ts
    let pwr_btn_recency=uptime-last_pwr_btn_ts

    if [ \( $pwr_btn_recency -lt 2 \) -a "$last_pwrmode" = "on" -a "$pwrmode" = "mem" ]
    then
        request="none"
    elif [ \( $pwr_btn_recency -lt 2 \) -a "$last_pwrmode" = "standby" -a "$pwrmode" = "mem" ]
    then
        request="none"
    elif [ $pwr_btn_recency -lt 2 ]
    then
        echo "let's see what happens ..."
        request="none"
    elif [ "$last_pwrmode" = "mem" -a "$pwrmode" != "mem" ]
    then
        request="none"
    elif [ \( $pwr_btn_recency -ge 2 \) -a \( $pwr_btn_recency -lt 10 \) -a \
         \( $sleep_recency -gt 10 \) -a \( $wakeup_recency -gt 10 \) ]
    then
        echo "button press not detected by system?"
        if [ "$pwrmode" != "mem" ]
        then
            request="sleep"
        else
            request="wake"
        fi
    elif [ \( $pwr_btn_recency -gt 10 \) -a "$last_pwrmode" != "mem" -a "$pwrmode" = "mem" ]
    then
        echo "system timed suspend detected"
        request="sleep"
    elif [ "$last_pwrmode" != "mem" -a \( $recency -gt $timeout \) ]
    then
        echo "button/pen activity timeout detected"
        request="sleep"
    elif [ "$last_pwrmode" = "mem" -a \( $btn_recency -lt 3 \) ]
    then
        echo "button activity detected"
        request="wake"
    fi
    echo "request is $request"

    let request_recency=uptime-last_request_ts
    if [ \( "$request" != "none" \) -a \( $request_recency -lt 10 \) ]
    then
        echo "last request was $request_recency s before, ignoring this request ..."
        request="none"
    fi

    if [ $request = "sleep" ]
    then
        echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        am broadcast -a refresh_screen
        c_pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
        if [ "$c_pwrmode" = "on" ]
        then
            echo "transition from on -> suspend ..."
            powerkey
            wait_for_mode mem
        elif [ "$c_pwrmode" = "standby" ]
        then
            echo "transition from standby -> mem -> on -> mem ..."
            powerkey
            wait_for_mode mem
            powerkey
            wait_for_mode on
            powerkey
            wait_for_mode mem
        fi
    elif [ $request = "resleep" ]
    then
        echo "transition from mem -> on -> mem ..."
        echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        c_pwrmode=$(/system/bin/getprop sys.onyx.pwrmode)
        if [ "$c_pwrmode" = "mem" ]
        then
            powerkey
            wait_for_mode on
            powerkey
            wait_for_mode mem
        fi
    elif [ $request = "wake" ]
    then
        echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        do_wake
        echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        svc power stayon true
        read_config
        am broadcast -a refresh_screen
        uptime=$(get_uptime)
        last_activity_ts=$uptime
    elif [ "$governor" != "interactive" ]
    then
        echo interactive > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
    else
        /system/bin/sleep 1
    fi
done
